import { supabase } from "@/integrations/supabase/client";

export interface SupportEngineer {
  id: string;
  user_id: string;
  role: 'support_engineer' | 'senior_support' | 'admin_support';
  is_active: boolean;
  can_request_sessions: boolean;
  added_by?: string;
  created_at: string;
  updated_at: string;
}

export interface RemoteSession {
  id: string;
  session_code: string;
  support_engineer_id: string;
  target_user_id: string;
  status: 'pending' | 'approved' | 'active' | 'completed' | 'denied' | 'cancelled';
  requested_at: string;
  approved_at?: string;
  started_at?: string;
  ended_at?: string;
  purpose?: string;
  notes?: string;
  metadata?: any;
  duration_minutes?: number;
  connection_quality?: string;
  resolution?: string;
  created_at: string;
  updated_at: string;
}

export interface SessionActivity {
  id: string;
  session_id: string;
  activity_type: string;
  description?: string;
  timestamp: string;
  metadata?: any;
}

export const remoteDesktopService = {
  // Support Engineer Management
  async addSupportEngineer(
    userId: string,
    role: SupportEngineer['role'] = 'support_engineer'
  ): Promise<{ data: SupportEngineer | null; error: any }> {
    const { data, error } = await supabase
      .from('support_engineers')
      .insert({
        user_id: userId,
        role,
        added_by: (await supabase.auth.getUser()).data.user?.id
      })
      .select()
      .single();

    return { data, error };
  },

  async getSupportEngineers(): Promise<{ data: SupportEngineer[] | null; error: any }> {
    const { data, error } = await supabase
      .from('support_engineers')
      .select('*')
      .order('created_at', { ascending: false });

    return { data, error };
  },

  async removeSupportEngineer(userId: string): Promise<{ error: any }> {
    const { error } = await supabase
      .from('support_engineers')
      .delete()
      .eq('user_id', userId);

    return { error };
  },

  async updateSupportEngineer(
    id: string,
    updates: Partial<SupportEngineer>
  ): Promise<{ data: SupportEngineer | null; error: any }> {
    const { data, error } = await supabase
      .from('support_engineers')
      .update(updates)
      .eq('id', id)
      .select()
      .single();

    return { data, error };
  },

  async checkIsSupportEngineer(userId?: string): Promise<boolean> {
    if (!userId) return false;

    const { data } = await supabase
      .from('support_engineers')
      .select('id')
      .eq('user_id', userId)
      .eq('is_active', true)
      .single();

    return !!data;
  },

  // Session Management
  async requestRemoteSession(
    targetUserId: string,
    purpose?: string
  ): Promise<{ data: RemoteSession | null; error: any }> {
    // First, get the current user's support engineer record
    const { data: user } = await supabase.auth.getUser();
    if (!user.user) {
      return { data: null, error: { message: 'User not authenticated' } };
    }

    const { data: supportEngineer } = await supabase
      .from('support_engineers')
      .select('id')
      .eq('user_id', user.user.id)
      .eq('is_active', true)
      .single();

    if (!supportEngineer) {
      return { data: null, error: { message: 'User is not a support engineer' } };
    }

    const { data, error } = await supabase
      .from('remote_sessions')
      .insert({
        support_engineer_id: supportEngineer.id,
        target_user_id: targetUserId,
        purpose,
        session_code: '' // Will be auto-generated by trigger
      })
      .select()
      .single();

    return { data, error };
  },

  async getSessionsByUser(userId: string): Promise<{ data: RemoteSession[] | null; error: any }> {
    const { data, error } = await supabase
      .from('remote_sessions')
      .select(`
        *,
        support_engineers (
          user_id
        )
      `)
      .or(`target_user_id.eq.${userId},support_engineers.user_id.eq.${userId}`)
      .order('created_at', { ascending: false });

    return { data, error };
  },

  async getPendingSessions(userId: string): Promise<{ data: RemoteSession[] | null; error: any }> {
    const { data, error } = await supabase
      .from('remote_sessions')
      .select(`
        *,
        support_engineers (
          user_id
        )
      `)
      .eq('target_user_id', userId)
      .eq('status', 'pending')
      .order('requested_at', { ascending: false });

    return { data, error };
  },

  async updateSessionStatus(
    sessionId: string,
    status: RemoteSession['status'],
    notes?: string
  ): Promise<{ data: RemoteSession | null; error: any }> {
    const updates: any = { status };
    
    if (status === 'approved') {
      updates.approved_at = new Date().toISOString();
    } else if (status === 'active') {
      updates.started_at = new Date().toISOString();
    } else if (status === 'completed') {
      updates.ended_at = new Date().toISOString();
    }

    if (notes) {
      updates.notes = notes;
    }

    const { data, error } = await supabase
      .from('remote_sessions')
      .update(updates)
      .eq('id', sessionId)
      .select()
      .single();

    return { data, error };
  },

  async getSessionByCode(code: string): Promise<{ data: RemoteSession | null; error: any }> {
    const { data, error } = await supabase
      .from('remote_sessions')
      .select('*')
      .eq('session_code', code)
      .single();

    return { data, error };
  },

  // Session Activities
  async logSessionActivity(
    sessionId: string,
    activityType: string,
    description?: string,
    metadata?: any
  ): Promise<{ error: any }> {
    const { error } = await supabase
      .from('session_activities')
      .insert({
        session_id: sessionId,
        activity_type: activityType,
        description,
        metadata
      });

    return { error };
  },

  async getSessionActivities(sessionId: string): Promise<{ data: SessionActivity[] | null; error: any }> {
    const { data, error } = await supabase
      .from('session_activities')
      .select('*')
      .eq('session_id', sessionId)
      .order('timestamp', { ascending: false });

    return { data, error };
  },

  // Real-time subscriptions
  subscribeToSessionUpdates(
    userId: string,
    callback: (payload: any) => void
  ) {
    return supabase
      .channel('session_updates')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'remote_sessions',
          filter: `target_user_id=eq.${userId}`
        },
        callback
      )
      .subscribe();
  },

  subscribeToSupportSessionUpdates(
    supportEngineerId: string,
    callback: (payload: any) => void
  ) {
    return supabase
      .channel('support_session_updates')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'remote_sessions',
          filter: `support_engineer_id=eq.${supportEngineerId}`
        },
        callback
      )
      .subscribe();
  }
};